#!/usr/bin/python

# Check out the README:
# https://github.com/edmund-huber/jsonq/blob/master/README.md

from optparse import OptionParser
import re
import sys

try:
    # simplejson is typically faster than standard-library json
    import simplejson as json
except ImportError:
    import json

def find(args):
    """Find candidate queries that would match elements in the data on stdin."""

    # build a query as we go down into the JSON, if we find something
    # that matches put said query into the return list.
    def find_matches(j, subs, query):
        def match(s):
            if subs in str(s):
                return [(query, j)]
            else:
                return []
        if type(j) == list:
            return reduce(lambda l, i_e: l + find_matches(i_e[1], subs, query + '[' + str(i_e[0]) + ']'), enumerate(j), [])
        elif type(j) == dict:
            return reduce(lambda l, k_v: l + match(k_v[0]) + find_matches(k_v[1], subs, query + '.' + k_v[0]), j.items(), [])
        else:
            return match(j)

    # report on which queries to use to find things.
    for line in sys.stdin:
        j = json.loads(line)
        print 'for the input:  %s' % json.dumps(j)
        for subs in args:
            for query, result in find_matches(j, subs, ''):
                print 'using query "%s", jsonq would find:  %s' % (query, result)

def parse_queries(query_strs):
    """Convert `query_str` (the command-line arguments) to parsed queries."""

    # parse the given queries. Each parsed query is a list of
    # tuples. The first element of each tuple, if not None, is a
    # dictionary key. The second element " " " ", is an array index.
    queries = []
    for query_s in query_strs:
        # detect fake queries:
        if query_s[0] not in ('.', '['):
            queries.append(query_s)
            continue

        original_query_s = query_s
        query = []
        while True:
            # dictionary keys may contain anything except ., [, or ], so [^.\[\]]+
            # maybe allow these chars also when backslash-escaped? meh.
            # array indices are digits, i.e., \d+
            m = re.match(r'((?P<select>\.[^.\[\]]+)|(?P<index>\[\d+\]))', query_s)
            if m:
                query_s = query_s[len(m.group(0)):]
                if m.group('select'):
                    q = m.group('select')[1:]
                    i = None
                elif m.group('index'):
                    q = None
                    i = int(m.group('index')[1:-1])
                else:
                    assert False
                query.append((q, i))
            elif query_s == '':
                break
            else:
                raise ValueError("Could not parse the query", original_query_s)
        queries.append(query)
    return queries

def query(queries, filter_data=False, strify=False):
    """Run `queries` against the data on stdin."""

    for line in sys.stdin:
        if not filter_data:
            j_orig = json.loads(line)

        for query in queries:
            # if it's a fake query, just print it
            if isinstance(query, basestring):
                print query,
                continue

            # reparse the data if we are destructively modifying it:
            if filter_data:
                j = json.loads(line)
            else:
                j = j_orig
            j_root = j
            try:
                for s, i in query:
                    if s is not None and i is None:
                        if filter_data:
                            for k in j.keys():
                                if k != s:
                                    del j[k]
                        j = j[s]
                    elif s is None and i is not None:
                        if filter_data:
                            j.append(j[i])
                            for _ in range(len(j) - 1):
                                j.pop(0)
                            j = j[0]
                        else:
                            j = j[i]
                    else:
                        assert False
            except KeyError:
                print 'null',
            else:
                obj_to_print = j_root if filter_data else j
                str_to_print = str(obj_to_print) if strify else json.dumps(obj_to_print)
                print str_to_print,
        print

def main():
    parser = OptionParser(usage="%prog [options] queries")
    parser.add_option('-f', '--find', dest='find', default=False, action='store_true',
            help="Emit all queries that would match any of the arguments.")
    parser.add_option('-i', '--filter', dest='filter', default=False, action='store_true',
            help="Show the original object filtered by the query, not just the result.")
    parser.add_option('-s', '--str', dest='str', default=False, action='store_true',
            help="Coerce output with str() instead of dumping JSON.")
    options, args = parser.parse_args()

    if options.find:
        return find(args)
    else:
        queries = parse_queries(args)
        return query(queries, filter_data=options.filter, strify=options.str)

if __name__ == '__main__':
    sys.exit(main())
